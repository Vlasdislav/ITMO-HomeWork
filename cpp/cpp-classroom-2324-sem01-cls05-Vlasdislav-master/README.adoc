== Задачи

== StringView
Реализуйте класс `StringView` (для элементов типа `char`; содержимое *необязательно* c-strings), `npos` и методы:

1. конструкторы: от си-строки, от `std::string`, от `char* + size_t` (указатель на начало + размер)
** `char* + size_t`: необязательно си-строка!
2. операторы присваивания: от си-строки, от `std::string`, от `StringView`
3. `data()`, `size()`
4. `substr` — возвращает `StringView`, принимает стартовый индекс + опциональный конечный индекс (default: `npos`)

ifdef::backend-revealjs[=== !]

5. `operator[]` — достает соответствующий индексу элемент
6. `find` — возвращает индекс начала подстроки или `npos`, принимает в аргументе `StringView` или `char`
7. `startsWith`, `endsWith` — принимает в аргументе `StringView` или `char`
8. `findFirstOf`, `findFirstNotOf` — _same_ + опциональный стартовый индекс (default: `0`)
9. `removePrefix` — сдвигает начало на `size_t` (аргумент), в самом объекте stringView

== LazyString
Будем разрабатывать строку:

* дешево копируемую (по сравнению с std::string)
* с методами-модификаторами (по сравнению с std::string_view)
  * => она *будет* хранить свои данные
* интефейс будет напоминать std::string

ifdef::backend-revealjs[=== !]

Реализация — через парадигму Copy-on-Write:

* данные в куче — и могут быть общими для нескольких объектов
  * например, при копировании объекта-строки, пока они не меняются по ходу программы
* при модификации объекта если владение данными у него не эксклюзивное => сперва копируются

=== SharedBuffer *[0.5 балла]*

Реализуйте класс `SharedBuffer`

* `SharedBuffer` хранит в себе (в куче) массив char и его размер
  * данные не обязательно null-terminated! точно известен их размер
* несколько таких объектов могут ссылаться на один и тот же участок памяти
* когда последний из них очищается, очищается и эта память

ifdef::backend-revealjs[=== !]

У `SharedBuffer` должны быть следующие методы:

* Конструктор от size_t и конструктор копирования
* Оператор присваивания
* `getSize` — возвращает размер данных
* `getData` — возвращает аллоцированный участок памяти (указатель на него)
* `useCount` — возвращает количество объектов, разделяющих данные (за O(1))

=== LazyString

Реализуйте класс `LazyString` (используя `SharedBuffer`!) c такими методами:

* Дефолтный конструктор
* Неявный конструктор от `char const*` (т.е. си-строки в данных)
* Конструктор копирования, оператор присваивания

ifdef::backend-revealjs[=== !]

* `getSize`
* `cStr`
* `useCount`
* `at`, возвращающий символ по индексу (копию)
** надо проверить индекс, если выход за границы — кидайте исключение [std::out_of_range](https://en.cppreference.com/w/cpp/error/out_of_range)
* `operator==`, внешний `operator+`, `operator+=`

=== CharWrapper *[0.5 балла]*
Реализуйте `LazyString::operator[]`, возвращающий специальную обертку над символом строки

* частично поддерживающую интерфейс `char&`: элемент можно сравнивать, присваивать, инкрементить
* при этом если `useCount > 1`:
** копирование строчки не происходит при read-only инструкциях (`s[2] == 'a'`)
** а происходит только на изменении данных (`s[2] = 'a'`)

ifdef::backend-revealjs[=== !]
